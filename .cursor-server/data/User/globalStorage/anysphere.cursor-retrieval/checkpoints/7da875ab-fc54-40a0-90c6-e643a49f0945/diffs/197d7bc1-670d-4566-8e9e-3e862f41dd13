{"fsPath":"\\home\\hendo420\\soraFeed\\src\\contexts\\GestureContext.tsx","fileUuid":"197d7bc1-670d-4566-8e9e-3e862f41dd13","fileSizeBytes":4073,"numLines":135,"diffChanges":[{"originalStartLineNumberOneIndexed":1,"originalEndLineNumberExclusiveOneIndexed":1,"modifiedStartLineNumberOneIndexed":1,"modifiedEndLineNumberExclusiveOneIndexed":136,"addedLines":["'use client';","","import React, { createContext, useContext, useCallback, useRef, useState } from 'react';","","export type GestureDirection = 'vertical' | 'horizontal' | null;","","interface GestureState {","  direction: GestureDirection;","  isActive: boolean;","  startX: number;","  startY: number;","  threshold: number;","}","","interface GestureContextType {","  gestureState: GestureState;","  startGesture: (clientX: number, clientY: number, threshold?: number) => void;","  updateGesture: (clientX: number, clientY: number) => GestureDirection;","  endGesture: () => void;","  isGestureActive: (direction: GestureDirection) => boolean;","  shouldBlockGesture: (direction: GestureDirection) => boolean;","}","","const GestureContext = createContext<GestureContextType | null>(null);","","export function GestureProvider({ children }: { children: React.ReactNode }) {","  const [gestureState, setGestureState] = useState<GestureState>({","    direction: null,","    isActive: false,","    startX: 0,","    startY: 0,","    threshold: 15","  });","","  const gestureRef = useRef<GestureState>(gestureState);","  gestureRef.current = gestureState;","","  const startGesture = useCallback((clientX: number, clientY: number, threshold: number = 15) => {","    console.log('🎯 Starting gesture at:', { clientX, clientY, threshold });","    const newState: GestureState = {","      direction: null,","      isActive: true,","      startX: clientX,","      startY: clientY,","      threshold","    };","    setGestureState(newState);","    gestureRef.current = newState;","  }, []);","","  const updateGesture = useCallback((clientX: number, clientY: number): GestureDirection => {","    const state = gestureRef.current;","    if (!state.isActive) return null;","","    const deltaX = Math.abs(clientX - state.startX);","    const deltaY = Math.abs(clientY - state.startY);","","    // Only determine direction once we've moved past the threshold","    if (deltaX > state.threshold || deltaY > state.threshold) {","      let direction: GestureDirection = null;","      ","      if (state.direction === null) {","        // Determine initial direction based on which axis has more movement","        if (deltaX > deltaY) {","          direction = 'horizontal';","          console.log('🔄 Gesture direction determined: HORIZONTAL', { deltaX, deltaY });","        } else if (deltaY > deltaX) {","          direction = 'vertical';","          console.log('🔄 Gesture direction determined: VERTICAL', { deltaX, deltaY });","        }","        ","        if (direction) {","          const newState = { ...state, direction };","          setGestureState(newState);","          gestureRef.current = newState;","        }","      } else {","        direction = state.direction;","      }","      ","      return direction;","    }","","    return state.direction;","  }, []);","","  const endGesture = useCallback(() => {","    console.log('🏁 Ending gesture');","    const newState: GestureState = {","      direction: null,","      isActive: false,","      startX: 0,","      startY: 0,","      threshold: 15","    };","    setGestureState(newState);","    gestureRef.current = newState;","  }, []);","","  const isGestureActive = useCallback((direction: GestureDirection): boolean => {","    const state = gestureRef.current;","    return state.isActive && (state.direction === direction || state.direction === null);","  }, []);","","  const shouldBlockGesture = useCallback((direction: GestureDirection): boolean => {","    const state = gestureRef.current;","    const shouldBlock = state.isActive && state.direction !== null && state.direction !== direction;","    if (shouldBlock) {","      console.log('🚫 Blocking gesture:', { requestedDirection: direction, activeDirection: state.direction });","    }","    return shouldBlock;","  }, []);","","  return (","    <GestureContext.Provider value={{","      gestureState,","      startGesture,","      updateGesture,","      endGesture,","      isGestureActive,","      shouldBlockGesture","    }}>","      {children}","    </GestureContext.Provider>","  );","}","","export function useGestureContext() {","  const context = useContext(GestureContext);","  if (!context) {","    throw new Error('useGestureContext must be used within a GestureProvider');","  }","  return context;","}",""],"tokenizedAddedLines":[1000000,1000001,1000002,1000001,1000003,1000001,1000004,1000005,1000006,1000007,1000008,1000009,1000010,1000001,1000011,1000012,1000013,1000014,1000015,1000016,1000017,1000010,1000001,1000018,1000001,1000019,1000020,1000021,1000022,1000023,1000024,1000025,1000026,1000001,1000027,1000028,1000001,1000029,1000030,1000031,1000032,1000033,1000034,1000035,1000036,1000037,1000038,1000039,1000040,1000001,1000041,1000042,1000043,1000001,1000044,1000045,1000001,1000046,1000047,1000048,1000049,1000050,1000051,1000052,1000053,1000054,1000055,1000056,1000057,1000058,1000059,1000060,1000061,1000062,1000063,1000058,1000064,1000065,1000066,1000049,1000067,1000068,1000001,1000069,1000040,1000001,1000070,1000071,1000031,1000032,1000072,1000073,1000074,1000075,1000037,1000038,1000039,1000040,1000001,1000076,1000042,1000077,1000040,1000001,1000078,1000042,1000079,1000080,1000081,1000068,1000082,1000040,1000001,1000083,1000084,1000085,1000086,1000087,1000088,1000089,1000090,1000091,1000092,1000093,1000094,1000010,1000001,1000095,1000096,1000097,1000098,1000099,1000100,1000010,1000001]}],"gitInfo":{"noRepoFound":true},"kind":"KIND_ADDED"}