{"fsPath":"\\home\\hendo420\\soraFeed\\src\\lib\\remixCache.ts","fileUuid":"493dd963-e1af-491b-bb84-d1e63b48a944","fileSizeBytes":6334,"numLines":246,"diffChanges":[{"originalStartLineNumberOneIndexed":1,"originalEndLineNumberExclusiveOneIndexed":1,"modifiedStartLineNumberOneIndexed":1,"modifiedEndLineNumberExclusiveOneIndexed":247,"addedLines":["import { SoraFeedItem, SoraFeedResponse } from '@/types/sora';","import { fetchRemixFeed } from './api';","","interface CachedRemixFeed {","  data: SoraFeedItem[];","  timestamp: number;","  postId: string;","}","","interface FetchQueueItem {","  postId: string;","  priority: number;","  retryCount: number;","}","","class RemixCacheManager {","  private cache: Map<string, CachedRemixFeed> = new Map();","  private fetchQueue: FetchQueueItem[] = [];","  private isFetching: boolean = false;","  private readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes","  private readonly MAX_RETRIES = 3;","  private readonly RETRY_DELAY = 1000; // 1 second","  private readonly CONCURRENT_FETCHES = 2;","  private activeFetches: Set<string> = new Set();","","  /**","   * Get remix feed from cache or fetch if not cached/expired","   */","  async getRemixFeed(postId: string): Promise<SoraFeedItem[]> {","    const cached = this.cache.get(postId);","    ","    // Check if cache is valid","    if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {","      console.log('✅ Cache hit for remix feed:', postId);","      return cached.data;","    }","","    // Cache miss or expired","    console.log('❌ Cache miss for remix feed:', postId, cached ? '(expired)' : '(not cached)');","    ","    // Try to fetch","    try {","      const response = await fetchRemixFeed(postId, 20);","      const remixes = response.items || [];","      ","      // Cache the result","      this.cache.set(postId, {","        data: remixes,","        timestamp: Date.now(),","        postId,","      });","      ","      return remixes;","    } catch (error) {","      console.error('❌ Failed to fetch remix feed:', postId, error);","      ","      // Return expired cache if available","      if (cached) {","        console.log('⚠️ Returning expired cache for:', postId);","        return cached.data;","      }","      ","      return [];","    }","  }","","  /**","   * Preload remix feeds for a list of posts","   */","  preloadRemixFeeds(posts: SoraFeedItem[]) {","    console.log('📦 Queueing', posts.length, 'posts for remix preload');","    ","    // Add posts to queue with priority based on order","    posts.forEach((post, index) => {","      const postId = post.post.id;","      ","      // Skip if already cached and valid","      const cached = this.cache.get(postId);","      if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {","        console.log('⏩ Skipping preload for cached:', postId);","        return;","      }","      ","      // Skip if already in queue","      if (this.fetchQueue.some(item => item.postId === postId)) {","        return;","      }","      ","      this.fetchQueue.push({","        postId,","        priority: index, // Lower number = higher priority","        retryCount: 0,","      });","    });","    ","    // Sort queue by priority","    this.fetchQueue.sort((a, b) => a.priority - b.priority);","    ","    // Start processing queue","    this.processQueue();","  }","","  /**","   * Process the fetch queue with concurrent fetches","   */","  private async processQueue() {","    if (this.isFetching) {","      return; // Already processing","    }","    ","    this.isFetching = true;","    ","    while (this.fetchQueue.length > 0 || this.activeFetches.size > 0) {","      // Start new fetches up to concurrent limit","      while (","        this.fetchQueue.length > 0 && ","        this.activeFetches.size < this.CONCURRENT_FETCHES","      ) {","        const item = this.fetchQueue.shift()!;","        this.fetchWithRetry(item);","      }","      ","      // Wait a bit before checking again","      await this.sleep(100);","    }","    ","    this.isFetching = false;","    console.log('✅ Remix preload queue completed');","  }","","  /**","   * Fetch remix feed with retry logic","   */","  private async fetchWithRetry(item: FetchQueueItem) {","    const { postId, retryCount } = item;","    ","    // Skip if already cached","    const cached = this.cache.get(postId);","    if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {","      return;","    }","    ","    this.activeFetches.add(postId);","    ","    try {","      console.log(`🔄 Fetching remix feed for ${postId} (attempt ${retryCount + 1})`);","      ","      const response = await fetchRemixFeed(postId, 20);","      const remixes = response.items || [];","      ","      // Cache the result","      this.cache.set(postId, {","        data: remixes,","        timestamp: Date.now(),","        postId,","      });","      ","      console.log(`✅ Cached ${remixes.length} remixes for ${postId}`);","      ","    } catch (error) {","      console.error(`❌ Failed to fetch remix feed for ${postId}:`, error);","      ","      // Retry if under max retries","      if (retryCount < this.MAX_RETRIES) {","        console.log(`🔄 Retrying ${postId} (${retryCount + 1}/${this.MAX_RETRIES})`);","        ","        // Wait before retry","        await this.sleep(this.RETRY_DELAY * (retryCount + 1));","        ","        // Re-add to queue with increased retry count","        this.fetchQueue.push({","          ...item,","          retryCount: retryCount + 1,","        });","      } else {","        console.error(`❌ Max retries exceeded for ${postId}`);","      }","    } finally {","      this.activeFetches.delete(postId);","    }","  }","","  /**","   * Clear expired cache entries","   */","  clearExpiredCache() {","    const now = Date.now();","    let cleared = 0;","    ","    for (const [postId, cached] of this.cache.entries()) {","      if (now - cached.timestamp >= this.CACHE_DURATION) {","        this.cache.delete(postId);","        cleared++;","      }","    }","    ","    if (cleared > 0) {","      console.log(`🧹 Cleared ${cleared} expired cache entries`);","    }","  }","","  /**","   * Clear all cache","   */","  clearAllCache() {","    this.cache.clear();","    console.log('🧹 Cleared all remix cache');","  }","","  /**","   * Get cache stats","   */","  getCacheStats() {","    const now = Date.now();","    const valid = Array.from(this.cache.values()).filter(","      c => now - c.timestamp < this.CACHE_DURATION","    ).length;","    ","    return {","      total: this.cache.size,","      valid,","      expired: this.cache.size - valid,","      queueLength: this.fetchQueue.length,","      activeFetches: this.activeFetches.size,","    };","  }","","  /**","   * Sleep helper","   */","  private sleep(ms: number): Promise<void> {","    return new Promise(resolve => setTimeout(resolve, ms));","  }","}","","// Singleton instance","export const remixCache = new RemixCacheManager();","","// Clear expired cache every minute","if (typeof window !== 'undefined') {","  setInterval(() => {","    remixCache.clearExpiredCache();","  }, 60 * 1000);","}","",""],"tokenizedAddedLines":[1000000,1000001,1000002,1000003,1000004,1000005,1000006,1000007,1000002,1000008,1000006,1000009,1000010,1000007,1000002,1000011,1000012,1000013,1000014,1000015,1000016,1000017,1000018,1000019,1000002,1000020,1000021,1000022,1000023,1000024,1000025,1000026,1000027,1000028,1000029,1000030,1000002,1000031,1000032,1000025,1000033,1000034,1000035,1000036,1000037,1000038,1000039,1000040,1000041,1000042,1000043,1000037,1000044,1000045,1000046,1000037,1000047,1000048,1000049,1000050,1000051,1000037,1000052,1000030,1000053,1000002,1000020,1000054,1000022,1000055,1000056,1000025,1000057,1000058,1000059,1000037,1000060,1000061,1000062,1000063,1000064,1000051,1000037,1000065,1000066,1000064,1000051,1000037,1000067,1000042,1000068,1000069,1000043,1000070,1000025,1000071,1000072,1000025,1000073,1000074,1000053,1000002,1000020,1000075,1000022,1000076,1000077,1000078,1000030,1000025,1000079,1000025,1000080,1000081,1000082,1000083,1000084,1000085,1000086,1000087,1000051,1000037,1000088,1000089,1000030,1000025,1000090,1000091,1000053,1000002,1000020,1000092,1000022,1000093,1000094,1000025,1000095,1000024,1000027,1000096,1000030,1000025,1000097,1000025,1000034,1000098,1000037,1000035,1000036,1000037,1000038,1000039,1000040,1000041,1000042,1000043,1000037,1000099,1000037,1000045,1000100,1000037,1000101,1000102,1000103,1000104,1000105,1000106,1000104,1000107,1000108,1000109,1000110,1000111,1000112,1000113,1000051,1000114,1000115,1000030,1000053,1000002,1000020,1000116,1000022,1000117,1000118,1000119,1000025,1000120,1000121,1000122,1000123,1000051,1000030,1000025,1000124,1000125,1000030,1000053,1000002,1000020,1000126,1000022,1000127,1000128,1000129,1000053,1000002,1000020,1000130,1000022,1000131,1000118,1000132,1000133,1000134,1000025,1000135,1000136,1000137,1000138,1000139,1000140,1000141,1000053,1000002,1000020,1000142,1000022,1000143,1000144,1000053,1000007,1000002,1000145,1000146,1000002,1000147,1000148,1000149,1000150,1000151,1000007,1000002,1000002]}],"gitInfo":{"noRepoFound":true},"kind":"KIND_ADDED"}